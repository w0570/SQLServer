/*
Deployment script for dbadmin_1

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;


GO
:setvar DatabaseName "dbadmin_1"
:setvar DefaultFilePrefix "dbadmin_1"
:setvar DefaultDataPath "C:\Users\Administrator.myitguide\AppData\Local\Microsoft\VisualStudio\SSDT\sqlserver"
:setvar DefaultLogPath "C:\Users\Administrator.myitguide\AppData\Local\Microsoft\VisualStudio\SSDT\sqlserver"

GO
:on error exit
GO
/*
Detect SQLCMD mode and disable script execution if SQLCMD mode is not supported.
To re-enable the script after enabling SQLCMD mode, execute the following:
SET NOEXEC OFF; 
*/
:setvar __IsSqlCmdEnabled "True"
GO
IF N'$(__IsSqlCmdEnabled)' NOT LIKE N'True'
    BEGIN
        PRINT N'SQLCMD mode must be enabled to successfully execute this script.';
        SET NOEXEC ON;
    END


GO
USE [$(DatabaseName)];


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET ARITHABORT ON,
                CONCAT_NULL_YIELDS_NULL ON,
                CURSOR_DEFAULT LOCAL 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET PAGE_VERIFY NONE,
                DISABLE_BROKER 
            WITH ROLLBACK IMMEDIATE;
    END


GO
ALTER DATABASE [$(DatabaseName)]
    SET TARGET_RECOVERY_TIME = 0 SECONDS 
    WITH ROLLBACK IMMEDIATE;


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET QUERY_STORE (CLEANUP_POLICY = (STALE_QUERY_THRESHOLD_DAYS = 367)) 
            WITH ROLLBACK IMMEDIATE;
    END


GO
PRINT N'Creating [dbo].[db_ErrorLog]...';


GO
CREATE TABLE [dbo].[db_ErrorLog] (
    [LogID]         BIGINT         IDENTITY (1, 1) NOT NULL,
    [ObjectName]    [sysname]      NOT NULL,
    [row_cnt]       INT            NULL,
    [SQLCommand]    NVARCHAR (MAX) NULL,
    [ErrorNumber]   INT            NULL,
    [ErrorSeverity] INT            NULL,
    [ErrorState]    INT            NULL,
    [ErrorMessage]  NVARCHAR (MAX) NULL,
    [DateApplied]   DATETIME       NULL
);


GO
PRINT N'Creating [dbo].[db_ErrorLog].[db_ErrorLog_idx_1]...';


GO
CREATE CLUSTERED INDEX [db_ErrorLog_idx_1]
    ON [dbo].[db_ErrorLog]([LogID] ASC);


GO
PRINT N'Creating [dbo].[db_excluded_index]...';


GO
CREATE TABLE [dbo].[db_excluded_index] (
    [LogID]      BIGINT         IDENTITY (1, 1) NOT NULL,
    [BatchID]    INT            NULL,
    [objectName] NVARCHAR (MAX) NULL,
    [indexName]  NVARCHAR (MAX) NULL,
    [IsIncluded] INT            NULL,
    [StatusID]   INT            NULL,
    [Notes]      NVARCHAR (MAX) NULL
);


GO
PRINT N'Creating [dbo].[db_excluded_index].[db_excluded_index_idx_1]...';


GO
CREATE CLUSTERED INDEX [db_excluded_index_idx_1]
    ON [dbo].[db_excluded_index]([LogID] ASC);


GO
PRINT N'Creating [dbo].[db_excluded_index].[db_excluded_index_idx_2]...';


GO
CREATE NONCLUSTERED INDEX [db_excluded_index_idx_2]
    ON [dbo].[db_excluded_index]([StatusID] ASC, [BatchID] ASC)
    INCLUDE([indexName], [objectName]);


GO
PRINT N'Creating [dbo].[db_indexDefragList]...';


GO
CREATE TABLE [dbo].[db_indexDefragList] (
    [LogID]           BIGINT     IDENTITY (1, 1) NOT NULL,
    [objectID]        INT        NULL,
    [indexID]         INT        NULL,
    [partitionNumber] INT        NULL,
    [fragmentation]   FLOAT (53) NULL,
    [page_count]      BIGINT     NULL,
    [defragStatus]    INT        NULL,
    [BatchID]         INT        NULL,
    [dss_update_date] DATETIME   NULL
);


GO
PRINT N'Creating [dbo].[db_indexDefragList].[db_indexDefragList_idx_1]...';


GO
CREATE CLUSTERED INDEX [db_indexDefragList_idx_1]
    ON [dbo].[db_indexDefragList]([LogID] ASC);


GO
PRINT N'Creating [dbo].[db_indexDefragList].[db_indexDefragList_idx_2]...';


GO
CREATE NONCLUSTERED INDEX [db_indexDefragList_idx_2]
    ON [dbo].[db_indexDefragList]([objectID] ASC, [indexID] ASC, [partitionNumber] ASC);


GO
PRINT N'Creating [dbo].[db_indexDefragList_LogID]...';


GO
CREATE TABLE [dbo].[db_indexDefragList_LogID] (
    [LogID] BIGINT NOT NULL
);


GO
PRINT N'Creating [dbo].[db_indexDefragList_LogID].[db_indexDefragList_idx_1_LogID]...';


GO
CREATE CLUSTERED INDEX [db_indexDefragList_idx_1_LogID]
    ON [dbo].[db_indexDefragList_LogID]([LogID] ASC);


GO
PRINT N'Creating [dbo].[db_indexDefragList_Monitor]...';


GO
CREATE TABLE [dbo].[db_indexDefragList_Monitor] (
    [LogID]           BIGINT     NOT NULL,
    [objectID]        INT        NULL,
    [indexID]         INT        NULL,
    [partitionNumber] INT        NULL,
    [fragmentation]   FLOAT (53) NULL,
    [page_count]      BIGINT     NULL,
    [defragStatus]    INT        NULL,
    [BatchID]         INT        NULL,
    [dss_update_date] DATETIME   NULL
);


GO
PRINT N'Creating [dbo].[db_indexDefragList_Monitor].[db_indexDefragList_Monitor_idx_1]...';


GO
CREATE CLUSTERED INDEX [db_indexDefragList_Monitor_idx_1]
    ON [dbo].[db_indexDefragList_Monitor]([LogID] ASC);


GO
PRINT N'Creating [dbo].[db_indexDefragList_Monitor].[db_indexDefragList_Monitor_idx_2]...';


GO
CREATE NONCLUSTERED INDEX [db_indexDefragList_Monitor_idx_2]
    ON [dbo].[db_indexDefragList_Monitor]([objectID] ASC, [indexID] ASC, [partitionNumber] ASC);


GO
PRINT N'Creating [dbo].[db_indexDefragList_Monitor].[NonClusteredIndex-20200501-212343]...';


GO
CREATE NONCLUSTERED INDEX [NonClusteredIndex-20200501-212343]
    ON [dbo].[db_indexDefragList_Monitor]([defragStatus] ASC, [fragmentation] ASC, [page_count] ASC);


GO
PRINT N'Creating [dbo].[db_reindexLog]...';


GO
CREATE TABLE [dbo].[db_reindexLog] (
    [indexDefrag_id]  BIGINT         IDENTITY (1, 1) NOT NULL,
    [LogID]           BIGINT         NULL,
    [dss_update_date] DATETIME       NULL,
    [objectID]        INT            NULL,
    [objectName]      NVARCHAR (MAX) NULL,
    [indexID]         INT            NULL,
    [indexName]       NVARCHAR (MAX) NULL,
    [partitionNumber] INT            NULL,
    [fragmentation]   FLOAT (53)     NULL,
    [page_count]      INT            NULL,
    [dateTimeStart]   DATETIME       NULL,
    [durationSeconds] INT            NULL,
    [SQLCommand]      NVARCHAR (MAX) NULL,
    [ReorgTag]        NVARCHAR (50)  NULL,
    [ErrorNumber]     INT            NULL,
    [ErrorSeverity]   INT            NULL,
    [ErrorState]      INT            NULL,
    [ErrorMessage]    NVARCHAR (MAX) NULL
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY];


GO
PRINT N'Creating [dbo].[db_reindexLog].[db_reindexLog_idx_1]...';


GO
CREATE NONCLUSTERED INDEX [db_reindexLog_idx_1]
    ON [dbo].[db_reindexLog]([indexDefrag_id] ASC);


GO
PRINT N'Creating [dbo].[sp_Who_Monitor2]...';


GO
CREATE TABLE [dbo].[sp_Who_Monitor2] (
    [LogID]         BIGINT          IDENTITY (1, 1) NOT NULL,
    [spid]          INT             NULL,
    [DBName]        NVARCHAR (128)  NULL,
    [Host]          NVARCHAR (128)  NULL,
    [Login]         NVARCHAR (128)  NULL,
    [EventInfo]     NVARCHAR (MAX)  NULL,
    [ObjectName]    NVARCHAR (257)  NULL,
    [CompanyName]   NVARCHAR (255)  NULL,
    [ElapsedMIN]    DECIMAL (12, 3) NULL,
    [ElapsedMS]     INT             NOT NULL,
    [CPUTime]       INT             NOT NULL,
    [IOReads]       BIGINT          NULL,
    [IOWrites]      BIGINT          NOT NULL,
    [LastWaitType]  NVARCHAR (60)   NOT NULL,
    [BlkBy]         SMALLINT        NULL,
    [CommandType]   NVARCHAR (16)   NOT NULL,
    [StartTime]     DATETIME        NOT NULL,
    [ClientAddress] VARCHAR (48)    NULL,
    [Status]        NVARCHAR (30)   NULL,
    [IsEmail]       TINYINT         NULL,
    CONSTRAINT [PK_sp_Who_Monitor2] PRIMARY KEY CLUSTERED ([LogID] ASC)
) ON [PRIMARY];


GO
PRINT N'Creating <unnamed>...';


GO
ALTER TABLE [dbo].[db_excluded_index]
    ADD DEFAULT ((1)) FOR [StatusID];


GO
PRINT N'Creating [dbo].[DF_sp_Who_Monitor2_IsEmail]...';


GO
ALTER TABLE [dbo].[sp_Who_Monitor2]
    ADD CONSTRAINT [DF_sp_Who_Monitor2_IsEmail] DEFAULT ((0)) FOR [IsEmail];


GO
PRINT N'Creating [dbo].[fn_getCompanyName]...';


GO
-- =============================================  
-- Author: Billie Lepasana
-- Create Date: 2011-11-24 -- (Its fall, mild chill, US Thanksgiving)
-- Description: Get Company Name based from a stored proc call
-- =============================================  
CREATE FUNCTION [dbo].[fn_getCompanyName]
(
	@param1 as nvarchar(max) -- stored proc call with parameters
)
RETURNS varchar(255)
BEGIN 
	DECLARE @companyname as varchar(255)

    RETURN @companyname
END
GO
PRINT N'Creating [dbo].[SP_Reindex]...';


GO
/******
Author: Billie Lepasana
Date Created:  May 1, 2020
SQL Server Version:  2016
Description:
Version History:
       1.0


******/
/********************************************************************
    Name:       dbo.SP_Reindex
    Purpose:    Defrags all indexes for the current database
    Notes:      This script was designed for SQL Server 2005
                Enterprise Edition.

                           Monitor transaction log if executing for the first time!

      @minFragmentation     defaulted to 10%, will not defrag if
                            fragmentation if less than specified.

      @rebuildThreshold     defaulted to 30% as recommended by
                            Microsoft in BOL;
                            > than 30% will result in rebuild instead

      @rebuildThresholdCritical     defaulted to 70%

      @onlineRebuild        1 = online rebuild;
                            0 = offline rebuild

      BDL: 2017-03-14, winter storm in Toronto
      * SQL Server 2008 and prior do not support REBUILD individual partition,
        it requires ALL, meaning entire index, and the table is not available
      * SQL Server 2012 support REBUILD each partition but do not support ONLINE,
          so the partition is still lock
      * SQL Server 2014 and beyond, support REBUILD ONLINE, each individual partition


      @executeSQL           1 = execute the SQL generated by this proc;
                            0 = print command only

      @tableName            Specify if you only want to defrag indexes
                            for a specific table

      @printCommands        1 = print commands to screen;
                            0 = do not print commands

      @printFragmentation   1 = print fragmentation to screen;
                            0 = do not print fragmentation

      @defragDelay          time to wait between defrag commands;
                            gives the server some time to catch up

    Called by:  SQL Agent Job or DBA

    Date        Initials  Description

********************************************************************
-- schedule execution
    Exec dba.SP_Reindex
          @executeSQL         = 1
        , @printCommands      = 0
        , @minFragmentation   = 0
        , @printFragmentation = 0;

-- manual execution
    Exec dba.SP_Reindex
          @executeSQL         = 1
        , @printCommands      = 1
        , @minFragmentation   = 0
        , @printFragmentation = 1;

-- Just to print the command
    Exec dba.SP_Reindex
          @executeSQL         = 0
        , @printCommands      = 1
        , @minFragmentation   = 0
        , @printFragmentation = 1;


********************************************************************/
CREATE PROCEDURE [dbo].[SP_Reindex]
AS
 
  SET XACT_ABORT OFF;
  SET NOCOUNT ON;

  SET deadlock_priority 1;

  --===============================================================
  -- Control variables used in most programs
  --===============================================================
  DECLARE
    @v_msgtext         varchar(256) -- Text for audit_trail
  , @v_step            integer      -- return code
  , @v_update_count    integer      -- no of records updated
  , @v_insert_count    integer      -- no of records inserted
  , @v_count           integer      -- General counter
  , @v_return_status   integer      -- Query result status
  , @v_row_count       integer      -- Query returned row count
  , @v_db_code         varchar(10)  -- Database error code
  , @v_db_msg          varchar(100) -- Database error message

  SET @v_step = 100;
  SET NOCOUNT ON;


DECLARE
       -- Add the parameters for the stored procedure here
    /* Declare Parameters */
      @minFragmentation     FLOAT           = 10.0
        /* in percent, will not defrag if fragmentation
           less than specified */
    , @rebuildThreshold     FLOAT           = 30.0
        /* in percent, greater than @rebuildThreshold
           will result in rebuild instead of reorg */
    , @rebuildThresholdCritical     FLOAT  = 70.0
        /* rebuild, it's critical */
    , @onlineRebuild        BIT             = 0
        /* 1 = online rebuild; 0 = offline rebuild */
    , @executeSQL           BIT             = 1
        /* 1 = execute; 0 = print command only */
    , @tableName            VARCHAR(4000)   = Null
        /* Option to specify a table name */
    , @printCommands        BIT             = 0
        /* 1 = print commands; 0 = do not print commands */
    , @printFragmentation   BIT             = 0
        /* 1 = print fragmentation prior to defrag;
           0 = do not print */
    , @defragDelay          CHAR(12)         = '00:00:00:003'
        /* time to wait between defrag commands */
    , @IsReindex                  BIT             = 1
        /* 1 = reindex; 0 = no Reindexing */
    , @IsLogExecution             BIT             = 1
        /* 1 = Log Execution to ReindexLog; 0 = no Logging */
    , @IsUpdateStats       BIT             = 1
        /* 1 = UpdateStats; 0 = No Update Stats */
    , @IsDisplay bit=1    -- 1 to display, 0 not
	, @MaxExecutionTime int = 18000
		/* seconds for max execution, 10800 sec = 3 hrs or 18000 secs =  5 hrs from 2 am till 7 am */
    , @IsClearExecutionLog bit=1 -- 0 if you dont want to clear ExecutionLog
	, @LogRetentionDays as int = 30 -- days for log retention
	, @p_batch_id         int = 1 -- [dbo].[db_excluded_index], default to ALL, without FILTER


  DECLARE
  	@paramName VARCHAR(64) = 'DB_Reindex_ExecutionTime',
	@paramComment VARCHAR(2000) = 'Number of seconds for reindexing to run before it Exit.',
	@paramValue VARCHAR(2000),
	@onlineRebuildVar bit,
	@dbmaxrun int,
	@batch_id as int = @p_batch_id,
	@dtMinExecutionLog as datetime = DATEADD(YEAR,-1,getdate())  -- default to 1 year
	;

  -- max run, starts at 2 am until 
	SET @dbmaxrun = 5
 -- no limit
 -- else
	--SET @dbmaxrun = 0
 -- ;
  -- online rebuild, its Standard, its not supported
	--SET @onlineRebuildVar = 1
 -- else
	SET @onlineRebuildVar = 0
  --;


--  set @MaxExecutionTime  = @dbmaxrun;
--  set @onlineRebuild = @onlineRebuildVar;


if @IsDisplay = 1 OR @printCommands = 1
  begin
       SET @printCommands = 1;
       SET @IsDisplay = 1;
  end

IF @IsDisplay = 1
BEGIN
	PRINT ''
	PRINT REPLICATE('=',50)
	PRINT 'Reindex and Update Stats'
	PRINT 'Start Processing '  + CONVERT(VARCHAR, GETDATE(), 121)
	PRINT REPLICATE('-',25)
	PRINT 'Server Name : ' + @@ServerName
	PRINT 'DB: ' + DB_name()
	PRINT REPLICATE('-',25)
	PRINT ''
END

       DECLARE
              -----------------------------
              -- Error Logging
                @ErrorNumber             INT
              , @ErrorSeverity     INT
              , @ErrorState        INT
              , @Switch                  BIT
              , @ErrorMessage            NVARCHAR(4000)

--///////////////////////////////
-- Variables
            , @objectID         INT
            , @indexID          INT
            , @LogID            BIGINT
            , @dss_update_date  DATETIME
            , @partitionCount   BIGINT
            , @schemaName       NVARCHAR(130)
            , @objectName       NVARCHAR(130)
            , @indexName        NVARCHAR(130)
            , @partitionNumber  SMALLINT
            , @partitions       SMALLINT
            , @fragmentation    FLOAT
            , @pageCount        INT
            , @sqlCommand       NVARCHAR(4000)
            , @rebuildCommand   NVARCHAR(200)
            , @dateTimeStart    DATETIME
            , @dateTimeEnd      DATETIME
            , @containsLOB      BIT
            , @RwCnt  int
			, @ServerStartTime  datetime = CURRENT_TIMESTAMP
			, @ServerEndTime  datetime = CURRENT_TIMESTAMP
			, @MaxExecutionTimeAllowed int = 10800		-- seconds, 3 hours

--///////////////////////////////
-- Others
            , @ReorgTag        NVARCHAR(130) = ''

;

-- Determine Product Version
DECLARE @ProdVersion as int, @ProdVersionTxt as nvarchar(10)
SELECT @ProdVersionTxt = CAST(SERVERPROPERTY('ProductVersion') AS nvarchar(10))
SELECT @ProdVersion = CAST(SUBSTRING(@ProdVersionTxt, 1,CHARINDEX('.',@ProdVersionTxt,1)-1) as int)
-- 9 - sql 2005, 10 - sql 2008, 11 - sql 2012, 12 - sql 2014, 13 - sql 2016
--14 - sql 2017, 15 - sql 2019



SET @v_step = 200;
--///////////////////////////////
-- Initialized
--///////////////////////////////
-- BEGIN
       -- make sure tempdb table doesn't exists
 --      if (object_id('tempdb..#indexDefragList') is not null)
 --                          drop table #indexDefragList

    /* Just a little validation... */
    IF @minFragmentation Not Between 0.00 And 100.0
        SET @minFragmentation = 10.0;

    IF @rebuildThreshold Not Between 0.00 And 100.0
        SET @rebuildThreshold = 30.0;

    IF @defragDelay Not Like '00:[0-5][0-9]:[0-5][0-9]'
        SET @defragDelay = '00:00:00:100';

    /* Determine which indexes to defrag using our
       user-defined parameters */

SET @v_step = 300;

       IF OBJECT_ID('tempdb..#indexDefragList') IS NOT NULL
        DROP TABLE #indexDefragList

       IF OBJECT_ID('tempdb..#indexDefragListIncluded') IS NOT NULL
        DROP TABLE #indexDefragListIncluded


	SELECT
	  OBJECT_ID AS objectID
	  , index_id AS indexID
	  , partition_number AS partitionNumber
	  , avg_fragmentation_in_percent AS fragmentation
	  , page_count
	  , 0 AS defragStatus
				/* 0 = unprocessed, 1 = processed */
	INTO #indexDefragList 
	  FROM sys.dm_db_index_physical_stats  
		(DB_ID(), OBJECT_ID(@tableName), NULL , NULL, N'Limited')
	WHERE avg_fragmentation_in_percent > @minFragmentation
		And index_id > 0
	OPTION (MaxDop 1);

       -- create #indexDefragListIncluded
       SELECT *
       INTO #indexDefragListIncluded
        FROM #indexDefragList
       WHERE 1=2

      -- EXCLUDE, always
      DELETE FROM #indexDefragList WHERE [objectID] in (SELECT OBJECT_ID from sys.objects WHERE name like 'partition_fn%')

      -- db_excluded_index BEGIN ----------------------------------------------------------
      -- 'ALL' means all database indexes ---
      IF NOT EXISTS(SELECT TOP 1 1 FROM db_excluded_index WHERE BatchID = @batch_id AND objectName='ALL' AND StatusID = 1)
      BEGIN
        -- IsIncluded=1, WHERE indexName is NOT null
        INSERT INTO [dbo].[#indexDefragListIncluded]
      	 ([objectID],[indexID],[partitionNumber],[fragmentation],[page_count],[defragStatus])
      	 SELECT t.objectID, t.indexID, t.partitionNumber, t.fragmentation, t.page_count, t.[defragStatus]
                  FROM sys.indexes i
                    INNER JOIN db_excluded_index l
                		ON i.object_id = OBJECT_ID(l.objectName) AND i.name = l.indexName
                	INNER JOIN #indexDefragList t ON i.object_id = t.objectID AND i.index_id = t.indexID
                WHERE l.BatchID = @batch_id AND l.IsIncluded=1 AND l.indexName is NOT null AND l.StatusID = 1

       END
      -- db_excluded_index END ----------------------------------------------------------


      -- Check existing snapshot BEGIN --------------------------------------------------
	  if NOT EXISTS(SELECT TOP 1 1 FROM [dbo].[db_indexDefragList] WHERE BatchID = @batch_id and defragStatus = 0)
	  BEGIN
            -- clear any remnants of previous ran on the batch, when all defragStatus = 1
            DELETE FROM [dbo].[db_indexDefragList] WHERE BatchID = @batch_id
       END
         ELSE
           BEGIN
             -- @rebuildThresholdCritical, always insert in every cycle
             DELETE FROM #indexDefragList WHERE fragmentation < @rebuildThresholdCritical
             DELETE FROM #indexDefragListIncluded WHERE fragmentation < @rebuildThresholdCritical
           END
      -- Check existing snapshot END --------------------------------------------------

      -- insert into defrag list --BEGIN -- Included
  	  INSERT INTO [dbo].[db_indexDefragList]
	  ([objectID],[indexID],[partitionNumber],[fragmentation],[page_count],[defragStatus],BatchID, dss_update_date)
		SELECT objectID, indexID, partitionNumber, fragmentation, page_count, defragStatus, @batch_id, getdate()
	          FROM #indexDefragListIncluded

       -- insert the rest
  	  INSERT INTO [dbo].[db_indexDefragList]
	  ([objectID],[indexID],[partitionNumber],[fragmentation],[page_count],[defragStatus],BatchID, dss_update_date)
		SELECT objectID, indexID, partitionNumber, fragmentation, page_count, defragStatus, @batch_id, getdate()
	          FROM #indexDefragList
      -- insert into defrag list -- END

         -- Remove Duplicates
         DELETE FROM [dbo].[db_indexDefragList] WHERE [BatchID] = @batch_id
         AND LogID IN
  	    (SELECT MIN([LogID])
	      FROM [dbo].[db_indexDefragList]
	      WHERE [BatchID] = @batch_id
	      GROUP BY  [objectID],[indexID],[partitionNumber]
	      HAVING Count(*) > 1
	      )


    -- Skip object no longer exists, or deleted, in existing lists
    UPDATE l SET defragStatus = 9
      FROM [db_indexDefragList] l
	  left outer join sys.indexes i on
         i.OBJECT_ID = l.objectID and i.index_id = l.indexID
      WHERE i.index_id is null

    /* Create a clustered index to boost performance a little */
--    CREATE CLUSTERED INDEX CIX_temp_indexDefragList
--        ON #indexDefragList(objectID, indexID, partitionNumber);


--- for test only, 2 index only -- ******************************
DECLARE @TestBit as tinyint = 0
--SET @TestBit = 0
IF @TestBit = 1
BEGIN
	IF OBJECT_ID('tempdb..#indexTempRun') IS NOT NULL
	DROP TABLE #indexTempRun

	SELECT TOP 2 * INTO #indexTempRun from [dbo].[db_indexDefragList]

	delete from [dbo].[db_indexDefragList]

     -- insert the rest
  	  INSERT INTO [dbo].[db_indexDefragList]
	  ([objectID],[indexID],[partitionNumber],[fragmentation],[page_count],[defragStatus],BatchID, dss_update_date)
		SELECT objectID, indexID, partitionNumber, fragmentation, page_count, defragStatus, @batch_id, getdate()
	          FROM #indexTempRun
END
--- for test only, 2 index only-- ******************************
TRUNCATE TABLE db_indexDefragList_LogID;			
TRUNCATE TABLE db_indexDefragList_Monitor;

INSERT INTO [dbo].[db_indexDefragList_Monitor]
           ([LogID],[objectID],[indexID]
           ,[partitionNumber],[fragmentation]
           ,[page_count],[defragStatus]
           ,[BatchID],[dss_update_date])

	SELECT [LogID],[objectID],[indexID]
			   ,[partitionNumber],[fragmentation]
			   ,[page_count],[defragStatus]
			   ,[BatchID],[dss_update_date]
	FROM [dbo].[db_indexDefragList];

INSERT INTO [dbo].[db_indexDefragList_LogID] ([LogID])
	SELECT [LogID] FROM [dbo].[db_indexDefragList] WHERE [defragStatus]=1 ;



SET @v_step = 400;
------------------------------------------- ///////////////////////////////////////////
/* Begin our loop for defragging */
WHILE EXISTS (SELECT TOP 1 1 FROM [dbo].[db_indexDefragList]
        WHERE defragStatus = 0 and BatchID = @batch_id
)
BEGIN
        -- reset Error Log
        SELECT @ErrorNumber=NULL
            , @ErrorSeverity=NULL
            , @ErrorState=NULL
            , @ErrorMessage=NULL;

		-- initialize reorg tag
		SET @ReorgTag = NULL;

        /* Grab the most fragmented index first to defrag */
        SELECT TOP 1
              @objectID         = objectID
			, @LogID			= LogID
			, @dss_update_date	= dss_update_date
            , @fragmentation    = fragmentation
            , @indexID          = indexID
            , @partitionNumber  = partitionNumber
            , @pageCount        = page_count
        FROM [dbo].[db_indexDefragList]
        WHERE defragStatus = 0
        AND BatchID = @batch_id
        ORDER BY ROUND(fragmentation,2) DESC, page_count DESC;

        /* Look up index information */
        SELECT @objectName = QUOTENAME(o.name)
             , @schemaName = QUOTENAME(s.name)
        FROM sys.objects AS o
        INNER Join sys.schemas AS s
            ON s.schema_id = o.schema_id
        WHERE o.OBJECT_ID = @objectID;

        SELECT @indexName = QUOTENAME(name)
        FROM sys.indexes
        WHERE OBJECT_ID = @objectID
            And index_id = @indexID
            And type > 0;

        /* Determine if the index is partitioned */
        SET @partitionCount = 1
        SELECT @partitionCount = COUNT(*)
        FROM sys.partitions
        WHERE OBJECT_ID = @objectID
            And index_id = @indexID;

        /* Look for LOBs */
        SET @containsLOB = 0
        SELECT TOP 1
            @containsLOB = column_id
        FROM sys.columns WITH (NOLOCK)
        WHERE
            [OBJECT_ID] = @objectID
            And (system_type_id In (34, 35, 99));
            -- 34 = image, 35 = text, 99 = ntext
            -- Or max_length = -1);  -- This is supported in SQL Server 2012
            -- varbinary(max), varchar(max), nvarchar(max), xml

       -------------------------------------------------------------------
       -- Determine which command to execute -- BEGIN
       SET @Switch = 0 -- @rebuildThresholdCritical - PARTITION=ALL
       SET @rebuildCommand = ' '

       if @ProdVersion < 9  -- Rebuild ONLINE is introduced in SQL Server 2005
         SET @onlineRebuild = 0
       -- 9 - sql 2005, 10 - sql 2008, 11 - sql 2012, 12 - sql 2014, 13 - sql 2016

        /* If our index is partitioned
          * SQL Server 2008 and prior do not support REBUILD individual partition,
            it requires ALL, meaning entire index, and the table is not available
          * SQL Server 2012 support REBUILD each partition but do not support ONLINE,
            so the partition is still lock
          * SQL Server 2014 and beyond, support REBUILD ONLINE, each individual partition
        */
        SET @sqlCommand = N'Alter Index ' + @indexName + N' On ' + @schemaName + N'.' + @objectName
        IF @partitionCount > 1
        BEGIN
              -- @rebuildThresholdCritical
              IF @fragmentation >= @rebuildThreshold
              BEGIN
                IF @onlineRebuild = 1 AND @ProdVersion = 11 -- SQL Server 2012 dont support ONLINE REBUILD single partition, always offline
                  SET @rebuildCommand = N' REBUILD Partition = ' + CAST(@partitionNumber AS NVARCHAR(10)) + N' With (MaxDop = 1)'
                ELSE
                  IF @onlineRebuild = 1 AND @ProdVersion > 11  -- SQL Server 2014 and beyond support ONLINE REBUILD single partition
                    SET @rebuildCommand = N' REBUILD Partition = ' + CAST(@partitionNumber AS NVARCHAR(10)) + N' With (Online = On, MaxDop = 1)'
                ELSE -- offline, non-enterprise
                  SET @rebuildCommand = N' REBUILD Partition = ' + CAST(@partitionNumber AS NVARCHAR(10)) + N' With (MaxDop = 1)'
              END
               ELSE
			     BEGIN
					SET @rebuildCommand = N' reorganize Partition = ' + CAST(@partitionNumber AS NVARCHAR(10))
					SET @ReorgTag  = ISNULL(@ReorgTag,'') + ' --1'
				 END
                -- no MaxDop needed, Reorganized is single threaded operation

              -- Override, SQL 2008 prior don't support REBUILD single partition, only reorg
              IF @ProdVersion <=  10
              BEGIN
                -- always reorg
                SET @rebuildCommand = ' reorganize ' 
				SET @ReorgTag  = ISNULL(@ReorgTag,'') + ' --2'
                -- REBUILD ALL, if @rebuildThresholdCritical, expensive ran
                IF @fragmentation >= @rebuildThresholdCritical
                BEGIN
                   SET @rebuildCommand = ' REBUILD '
                 END
              END

        END
         ELSE -- If our index is NOT partitioned
          BEGIN
              /* We should always rebuild online if possible (SQL 2005 Enterprise ONLY) */
              IF @fragmentation >= @rebuildThreshold
              BEGIN
                IF @onlineRebuild = 1
                  SET @rebuildCommand = N' REBUILD With (Online = On, MaxDop = 1)'
                ELSE -- offline, non-enterprise
                  SET @rebuildCommand = N' REBUILD With (MaxDop = 1)'
              END
               ELSE
			     BEGIN
					 SET @rebuildCommand = ' reorganize ' 
					 SET @ReorgTag  = ISNULL(@ReorgTag,'') + ' --3'
				  END
                -- no MaxDop needed, Reorganized is single threaded operation

          END;

        SET @sqlCommand = @sqlCommand + @rebuildCommand ;


        /* Override - Cannot rebuild if the table has one or more LOB, we should always reorganize */
        IF IsNull(@containsLOB, 0) > 0
        BEGIN
		   SET @ReorgTag  = ISNULL(@ReorgTag,'') + ' --4'	
           SET @sqlCommand = N'Alter Index ' + @indexName + N' On ' + @schemaName + N'.' + @objectName + N' ReOrganize ';
		   
           -- no MaxDop needed, Reorganized is single threaded operation
        END

       -- Determine which command to execute -- END
       -------------------------------------------------------------------


        /* Are we executing the SQL?  If so, do it */
        IF @executeSQL = 1 AND @IsReindex = 1
        BEGIN
                     SELECT @ErrorNumber=null
                     , @ErrorSeverity=null
                     , @ErrorState=null
                     , @ErrorMessage=null;

            /* Grab the time for logging purposes */
            SET @dateTimeStart  = CURRENT_TIMESTAMP;

                     BEGIN TRY
                          EXECUTE (@sqlCommand);
                     END TRY
                           BEGIN CATCH
                                  SELECT @ErrorNumber=ERROR_NUMBER()
                                  , @ErrorSeverity=ERROR_SEVERITY()
                                  , @ErrorState=ERROR_STATE()
                                  , @ErrorMessage=ERROR_MESSAGE();

                                  INSERT INTO [dbo].[db_ErrorLog]
                                     ([ObjectName] ,[ErrorNumber],[ErrorSeverity],
                                         [ErrorState],[ErrorMessage],[DateApplied], SQLCommand)

                                  SELECT @objectName,
                                         @ErrorNumber,
                                         @ErrorSeverity,
                                         @ErrorState,
                                         @ErrorMessage, getdate(), @sqlCommand
                           END CATCH

            SET @dateTimeEnd  = CURRENT_TIMESTAMP;

            /* Log our actions */
                     IF @IsLogExecution = 1
                     BEGIN
                           INSERT INTO [dbo].[db_reindexLog]
                           (
                                    objectID
                                  , objectName
                                  , indexID
                                  , indexName
                                  , partitionNumber
                                  , fragmentation
                                  , page_count
                                  , dateTimeStart
                                  , durationSeconds
                                  ,[ErrorNumber],[ErrorSeverity],[ErrorState],[ErrorMessage],SQLCommand, ReorgTag, LogID, dss_update_date
                           )
                           SELECT
                                    @objectID
                                  , @objectName
                                  , @indexID
                                  , @indexName
                                  , @partitionNumber
                                  , @fragmentation
                                  , @pageCount
                                  , @dateTimeStart
                                  , DATEDIFF(SECOND, @dateTimeStart, @dateTimeEnd)
                                  , @ErrorNumber,@ErrorSeverity,@ErrorState,@ErrorMessage, @sqlCommand, @ReorgTag,@LogID, @dss_update_date;
                     END
            /* Just a little breather for the server */
            WAITFOR Delay @defragDelay;

            /* Print if specified to do so */
            IF @printCommands = 1
                PRINT CONVERT(VARCHAR, GETDATE(), 121) + ' : ' + N'Executed: ' + @sqlCommand +RTRIM(@ReorgTag);
		END
        ELSE
        /* Looks like we're not executing, just print
            the commands */
        BEGIN
            IF @printCommands = 1
                PRINT CONVERT(VARCHAR, GETDATE(), 121) + ' : ' + N'NOT Executed: ' + @sqlCommand +RTRIM(@ReorgTag);
        END


       -- for small table, even rebuild doesnt defrag, reoganize fixes the fragmentation
       IF EXISTS(SELECT top 1 1  FROM sys.dm_db_index_physical_stats(db_id(),@objectID, @indexID, @partitionNumber, NULL) where avg_fragmentation_in_percent >= @fragmentation)
        BEGIN
             IF @partitionCount > 1
               SET @sqlCommand = N'Alter Index ' + @indexName + N' On ' + @schemaName + N'.' + @objectName + N' reorganize Partition = ' + CAST(@partitionNumber AS NVARCHAR(10))
             ELSE
                SET @sqlCommand = N'Alter Index ' + @indexName + N' On ' + @schemaName + N'.' + @objectName + N' reorganize '

			 SET @ReorgTag  = @ReorgTag + ' --5'
			 SET @sqlCommand =@sqlCommand

			IF @executeSQL = 1 AND @IsReindex = 1
			BEGIN
				 BEGIN TRY
					EXECUTE (@sqlCommand);
				 END TRY
				 BEGIN CATCH
						SELECT @ErrorNumber=ERROR_NUMBER()
						, @ErrorSeverity=ERROR_SEVERITY()
						, @ErrorState=ERROR_STATE()
						, @ErrorMessage=ERROR_MESSAGE();

						INSERT INTO [dbo].[db_ErrorLog]
						   ([ObjectName] ,[ErrorNumber],[ErrorSeverity],
							   [ErrorState],[ErrorMessage],[DateApplied], SQLCommand)

						SELECT @objectName,
							   @ErrorNumber,
							   @ErrorSeverity,
							   @ErrorState,
							   @ErrorMessage, getdate(), @sqlCommand
				   END CATCH

            /* Log our actions */
                     IF @IsLogExecution = 1
                     BEGIN
                           INSERT INTO [dbo].[db_reindexLog]
                           (
                                    objectID
                                  , objectName
                                  , indexID
                                  , indexName
                                  , partitionNumber
                                  , fragmentation
                                  , page_count
                                  , dateTimeStart
                                  , durationSeconds
                                  ,[ErrorNumber],[ErrorSeverity],[ErrorState],[ErrorMessage],SQLCommand, ReorgTag,LogID, dss_update_date
                           )
                           SELECT
                                    @objectID
                                  , @objectName
                                  , @indexID
                                  , @indexName
                                  , @partitionNumber
                                  , @fragmentation
                                  , @pageCount
                                  , @dateTimeStart
                                  , DATEDIFF(SECOND, @dateTimeStart, @dateTimeEnd)
                                  , @ErrorNumber,@ErrorSeverity,@ErrorState,@ErrorMessage, @sqlCommand,@ReorgTag,@LogID, @dss_update_date;
                     END
				/* Just a little breather for the server */
				WAITFOR Delay @defragDelay;
				/* Print if specified to do so */
				IF @printCommands = 1
					PRINT CONVERT(VARCHAR, GETDATE(), 121) + ' : ' + N'Executed: ' + @sqlCommand +RTRIM(@ReorgTag);
			END
				ELSE
				/* Looks like we're not executing, just print
					the commands */
				BEGIN
					IF @printCommands = 1
						PRINT CONVERT(VARCHAR, GETDATE(), 121) + ' : ' +  N'NOT Executed: ' + @sqlCommand +RTRIM(@ReorgTag);
				END
         END
        -- for small table, even rebuild doesnt defrag, reoganize fixes the fragmentation

        /* Update our index defrag list when we've
            finished with that index */
			UPDATE [dbo].[db_indexDefragList]
			SET defragStatus = 1
			WHERE LogID = @LogID;

			WAITFOR Delay @defragDelay

			INSERT INTO [dbo].[db_indexDefragList_LogID](LogID) VALUES(@LogID)		
        --WHERE objectID         = @objectID
        --  And indexID          = @indexID
        --  And partitionNumber  = @partitionNumber
        --  AND BatchID = @batch_id;

		-- check execution time
		SET @ServerEndTime  = CURRENT_TIMESTAMP;
		IF DATEDIFF(SECOND, @ServerStartTime, @ServerEndTime) > @MaxExecutionTime
		BEGIN
			BREAK;
		END
END
/* END our loop for defragging */
------------------------------------------- ///////////////////////////////////////////
SET @v_step = 500;
    /* Do we want to output our fragmentation results? */
    IF @printFragmentation = 1
        SELECT idl.objectID
            , o.name AS 'tableName'
            , idl.indexID
            , i.name AS 'indexName'
            , idl.fragmentation
            , idl.page_count
        FROM db_indexDefragList AS idl
        Join sys.objects AS o
            ON idl.objectID = o.OBJECT_ID
        Join sys.indexes AS i
            ON idl.objectID = i.OBJECT_ID
            And idl.indexID = i.index_id
         and idl.BatchID = @batch_id   ;

    /* When everything is done, make sure to get rid of
        our temp table */
    --DROP TABLE #indexDefragList;
SET @v_step = 600;
    IF @executeSQL = 1 AND @IsUpdateStats = 1
    BEGIN
              SELECT @ErrorNumber=null
              , @ErrorSeverity=null
              , @ErrorState=null
              , @ErrorMessage=null;

              /* Grab the time for logging purposes */
              PRINT ''
              SET @dateTimeStart  = GETDATE();
              SET @sqlCommand = 'EXEC sp_updatestats'
              PRINT CONVERT(VARCHAR, GETDATE(), 121) + ' : ' +  'Updating Statistics ' ;
              BEGIN TRY
                     /*  sp_updatestats is the best option here.
                           Especially considering the changes in sp_updatestats in 2005
                           where it will only update stats that are outdated instead of all of them. */
                     EXEC sp_updatestats
              END TRY
                     BEGIN CATCH
                           SELECT @ErrorNumber=ERROR_NUMBER()
                           , @ErrorSeverity=ERROR_SEVERITY()
                           , @ErrorState=ERROR_STATE()
                           , @ErrorMessage=ERROR_MESSAGE();

                           INSERT INTO [dbo].[db_ErrorLog]
                              ([ObjectName] ,[ErrorNumber],[ErrorSeverity],
                                  [ErrorState],[ErrorMessage],[DateApplied], SQLCommand)

                           SELECT @objectName,
                                  @ErrorNumber,
                                  @ErrorSeverity,
                                  @ErrorState,
                                  @ErrorMessage, getdate(), @sqlCommand
                     END CATCH

        SET @dateTimeEnd  = GETDATE();

                     IF @IsLogExecution = 1
                     BEGIN
						   SET @ReorgTag=null;
                           INSERT INTO dbo.db_reindexLog
                           (
                                    objectID
                                  , objectName
                                  , indexID
                                  , indexName
                                  , partitionNumber
                                  , fragmentation
                                  , page_count
                                  , dateTimeStart
                                  , durationSeconds
                                  ,[ErrorNumber],[ErrorSeverity],[ErrorState],[ErrorMessage],SQLCommand,ReorgTag,LogID, dss_update_date
                           )
                           SELECT
                                    database_id
                                  , [name]
                                  , NULL
                                  , 'Update stats'
                                  , NULL
                                  , NULL
                                  , NULL
                                  , @dateTimeStart
                                  , DATEDIFF(SECOND, @dateTimeStart, @dateTimeEnd)
                                  ,@ErrorNumber,@ErrorSeverity,@ErrorState,@ErrorMessage, @sqlCommand,@ReorgTag,@LogID, @dss_update_date
                           from sys.databases WHERE [name] = DB_name();
                     END
       END

    -- reinitialized the table for the next run
	IF NOT EXISTS (SELECT TOP 1 1 FROM [dbo].[db_indexDefragList]
        WHERE defragStatus = 0 AND BatchID = @batch_id)
	BEGIN
		DELETE FROM [dbo].[db_indexDefragList] WHERE BatchID = @batch_id
	END
	;

	-- clear execution log
	IF @IsClearExecutionLog=1 -- 0 if you dont want to clear ExecutionLog
	begin
	       SET @LogRetentionDays = @LogRetentionDays * -1 -- days for log retention
		SET @dtMinExecutionLog = DATEADD(DAY,@LogRetentionDays, @ServerEndTime)

		DELETE FROM [dbo].[db_reindexLog] WHERE dateTimeStart < @dtMinExecutionLog
		DELETE FROM [dbo].[db_ErrorLog] WHERE DateApplied < @dtMinExecutionLog
	end

SET @v_step = 700;
IF @IsDisplay = 1
BEGIN
	PRINT ''
	PRINT 'End Processing ' + CONVERT(VARCHAR, GETDATE(), 121);
	PRINT REPLICATE('=',50)
END
--SET @p_status = 1;
--SET @p_return_msg = 'SP_Reindex completed.';
RETURN 0;
GO
PRINT N'Creating [dbo].[Tools_KillConnection]...';


GO
CREATE PROCEDURE [dbo].[Tools_KillConnection]
AS
    DECLARE @spid int
    DECLARE @sql varchar(MAX)

    DECLARE cur CURSOR FOR
        SELECT spid FROM sys.sysprocesses P
            JOIN sys.sysdatabases D ON (D.dbid = P.dbid)
            JOIN sys.sysusers U ON (P.uid = U.uid)
            AND P.spid != @@SPID

    OPEN cur

    FETCH NEXT FROM cur
        INTO @spid

    WHILE @@FETCH_STATUS = 0
    BEGIN
        PRINT CONVERT(varchar, @spid)

        SET @sql = 'KILL ' + RTRIM(@spid)
        PRINT @sql
        EXEC(@sql)

        FETCH NEXT FROM cur
            INTO @spid
    END

    CLOSE cur
    DEALLOCATE cur
GO
PRINT N'Creating [dbo].[Tools_Sp_Who_Monitor2]...';


GO
/*
 Author: Billie D. Lepasana
 Date Created:  Oct 7, 2011 @ 10am EST
 SQL Server Version:  2008
 Description:
    Customized sp_who, with CompanyID 
    Utilizing fn_getCompanyName

 Version History:
	1.0

*/
CREATE PROCEDURE [dbo].[Tools_Sp_Who_Monitor2]
--///////////////////////////////
-- Parameters
	  @dys int = 7	-- days retention on log table
	 ,@hrsToDel int = 8 -- delete log at this hrs, default to 8am daily
--------------------------------------------
	 ,@IsDisplay				BIT             = 1
        /* 1 to display feedback msg, 0 not */

AS
SET NOCOUNT ON;
SET XACT_Abort ON;

IF @IsDisplay = 1
BEGIN
 PRINT ''
 PRINT REPLICATE('=',50)
 PRINT 'Start Processing ' + CONVERT(VarChar(20), GETDATE(), 109)
 PRINT REPLICATE('-',25)
 PRINT 'Server Name : ' + @@ServerName 
 PRINT 'DB: ' + DB_name()
 PRINT REPLICATE('-',25)
 PRINT ''
END

BEGIN TRY		
	DECLARE 
		-----------------------------
		-- Error Logging
        @Proc	NVARCHAR(75) = 'Tools_Sp_Who2'
--///////////////////////////////
-- Variables
	   ,@dateTimeEnd DATETIME

--///////////////////////////////
-- Initialized



--///////////////////////////////
-- BEGIN Process
		if (object_id('tempdb..#spWho') is not null)
			drop table #spWho

		SELECT 			SPID                = er.session_id  
			,@@SERVERNAME ServerName
			,Status             = ses.status  
			,[Login]            = ses.login_name  
			,Host               = ses.host_name  
			,BlkBy              = er.blocking_session_id  
			,DBName             = DB_Name(er.database_id)  
			,CommandType        = er.command  
			,SQLStatement       =  
				SUBSTRING 
				(  
					qt.text,  
					er.statement_start_offset/2,  
					(CASE WHEN er.statement_end_offset = -1  
						THEN LEN(CONVERT(nvarchar(MAX), qt.text)) * 2  
						ELSE er.statement_end_offset  
						END - er.statement_start_offset)/2  
				)  
			,ObjectName         = OBJECT_SCHEMA_NAME(qt.objectid,dbid) + '.' + OBJECT_NAME(qt.objectid, qt.dbid)  
			,ElapsedMS          = er.total_elapsed_time  
			,CPUTime            = er.cpu_time  
			,IOReads            = er.logical_reads + er.reads  
			,IOWrites           = er.writes  
			,LastWaitType       = er.last_wait_type  
			,StartTime          = er.start_time  
			,Protocol           = con.net_transport  
			,transaction_isolation =  
				CASE ses.transaction_isolation_level  
					WHEN 0 THEN 'Unspecified' 
					WHEN 1 THEN 'Read Uncommitted' 
					WHEN 2 THEN 'Read Committed' 
					WHEN 3 THEN 'Repeatable' 
					WHEN 4 THEN 'Serializable' 
					WHEN 5 THEN 'Snapshot' 
				END 
			,ConnectionWrites   = con.num_writes  
			,ConnectionReads    = con.num_reads  
			,ClientAddress      = con.client_net_address  
			,Authentication     = con.auth_scheme  
		---------------------------
		INTO #spWho 
		---------------------------
			FROM sys.dm_exec_requests er  
				LEFT JOIN sys.dm_exec_sessions ses  ON ses.session_id = er.session_id  
				LEFT JOIN sys.dm_exec_connections con  ON con.session_id = ses.session_id  
				OUTER APPLY sys.dm_exec_sql_text(er.sql_handle) as qt  

		WHERE ses.status   = 'running'
			ORDER BY 
			CPUTime desc,
			IOReads DESC

	--------------------------------------------------------------------------------------
	-- Query 01
	--SELECT *  FROM #spWho 
	--	ORDER BY ElapsedMS desc
	--------------------------------------------------------------------------------------
	DECLARE 
	     @ExecSql varchar(max)
   
	if (object_id('tempdb..#InpbufTmp') is not null)
		drop table #InpbufTmp


	CREATE TABLE #InpbufTmp(
	EventType NVARCHAR(MAX) NULL,
	Parameters INT NULL,
	EventInfo NVARCHAR(MAX) NULL
	)

	if (object_id('tempdb..#Inpbuffer') is not null)
		drop table #Inpbuffer

	CREATE TABLE #Inpbuffer(
	spid int,
	EventInfo NVARCHAR(MAX) NULL,
	CompanyName nvarchar(255)
	)


	SET @ExecSql = 'DECLARE @tBuff varchar(max); SET @tBuff = ''''; '
		SELECT TOP 10
		  @ExecSql +=  '  INSERT #InpbufTmp EXEC( '' DBCC INPUTBUFFER(' + RTRIM(spid) + ')''); SET @tBuff = (SELECT TOP 1 EventInfo FROM #InpbufTmp); INSERT INTO #Inpbuffer(spid,EventInfo,CompanyName) values (' + RTRIM(spid) + ', @tBuff, dbo.fn_getCompanyName(@tBuff)); DELETE FROM #InpbufTmp; '
		FROM #spWho 
		ORDER BY  CPUTime desc,	IOReads DESC
	PRINT RTRIM(@ExecSql)
	EXEC(@ExecSql) 

	--------------------------------------------------------------------------------------
	-- Query 02
	IF DATEPART(hh, getdate()) = @hrsToDel AND DATEPART(MINUTE, getdate()) < 15	-- top of the hour
	BEGIN
		DELETE FROM [dbo].[sp_Who_Monitor2]
			WHERE DATEDIFF(DAY, StartTime, GETDATE()) >=@dys
	END

	-- Filter out some internal queries
	DELETE FROM #spWho
	WHERE ObjectName IN 
	('sys.sp_trace_getdata','sys.sp_trace_getdata', 'dbo.sp_ListLongRunningSessions','sys.sp_reset_connection;1', 'dbo.pr_PROC_CompareMiles_on_Dailymiles_and_Events')
	-- Filter out some internal queries
	
	insert into dbo.[sp_Who_Monitor2]
	(	spid, DBName, Host,[Login],EventInfo,ObjectName,CompanyName,
			ElapsedMIN, ElapsedMS, CPUTime,IOReads,IOWrites,		
		LastWaitType,BlkBy,CommandType,StartTime,ClientAddress,[Status]
	)

	SELECT b.spid, w.DBName, w.Host, w.[Login], b.EventInfo, w.ObjectName, b.CompanyName, cast((w.ElapsedMS/1000)/60 as decimal(12,3)) ElapsedMIN, w.ElapsedMS, w.CPUTime, w.IOReads, w.IOWrites,
		w.LastWaitType, w.BlkBy, w.CommandType, w.StartTime,  w.ClientAddress, w.[Status]
		FROM #Inpbuffer b
	  INNER JOIN #spWho w on b.spid = w.SPID
	--WHERE b.CompanyName IS NOT NULL
	ORDER BY  w.CPUTime desc,
		w.IOReads DESC
	--------------------------------------------------------------------------------------	


-- END Process
--///////////////////////////////

END TRY
	BEGIN CATCH

		
		SELECT RTRIM(@Proc) , ERROR_NUMBER() 'ERROR_NUMBER'
		, ERROR_SEVERITY() as 'ERROR_SEVERITY'
		, ERROR_STATE() as 'ERROR_STATE'
		, ERROR_MESSAGE() as 'ERROR_MESSAGE';

	END CATCH

    SET @dateTimeEnd  = GETDATE();


IF @IsDisplay = 1
BEGIN
 PRINT ''
 PRINT 'End Processing ' + CONVERT(VarChar(20), GETDATE(), 109)
END

SET NOCOUNT OFF
RETURN
GO
PRINT N'Creating [dbo].[Tools_Sp_Who2]...';


GO
/*
 Author: Billie D. Lepasana
 Date Created:  Oct 7, 2011 @ 10am EST
 SQL Server Version:  2008
 Description:
    Customized sp_who, with CompanyID on pr_CGui_RPT_EventDetailDriver
    Utilizing fn_getCompanyName

 Version History:
	1.0

*/
CREATE PROCEDURE [dbo].[Tools_Sp_Who2]
--///////////////////////////////
-- Parameters
	
--------------------------------------------
	 @IsDisplay				BIT             = 1
        /* 1 to display feedback msg, 0 not */

AS
SET NOCOUNT ON;
SET XACT_Abort ON;

IF @IsDisplay = 1
BEGIN
 PRINT ''
 PRINT REPLICATE('=',50)
 PRINT 'Start Processing ' + CONVERT(VarChar(20), GETDATE(), 109)
 PRINT REPLICATE('-',25)
 PRINT 'Server Name : ' + @@ServerName 
 PRINT 'DB: ' + DB_name()
 PRINT REPLICATE('-',25)
 PRINT ''
END

BEGIN TRY		
	DECLARE 
		-----------------------------
		-- Error Logging
        @Proc	NVARCHAR(75) = 'Tools_Sp_Who2'
--///////////////////////////////
-- Variables
	   ,@dateTimeEnd DATETIME

--///////////////////////////////
-- Initialized



--///////////////////////////////
-- BEGIN Process
		if (object_id('tempdb..#spWho') is not null)
			drop table #spWho

		SELECT 			SPID                = er.session_id  
			,@@SERVERNAME ServerName
			,Status             = ses.status  
			,[Login]            = ses.login_name  
			,Host               = ses.host_name  
			,BlkBy              = er.blocking_session_id  
			,DBName             = DB_Name(er.database_id)  
			,CommandType        = er.command  
			,SQLStatement       =  
				SUBSTRING 
				(  
					qt.text,  
					er.statement_start_offset/2,  
					(CASE WHEN er.statement_end_offset = -1  
						THEN LEN(CONVERT(nvarchar(MAX), qt.text)) * 2  
						ELSE er.statement_end_offset  
						END - er.statement_start_offset)/2  
				)  
			,ObjectName         = OBJECT_SCHEMA_NAME(qt.objectid,dbid) + '.' + OBJECT_NAME(qt.objectid, qt.dbid)  
			,ElapsedMS          = er.total_elapsed_time  
			,CPUTime            = er.cpu_time  
			,IOReads            = er.logical_reads + er.reads  
			,IOWrites           = er.writes  
			,LastWaitType       = er.last_wait_type  
			,StartTime          = er.start_time  
			,Protocol           = con.net_transport  
			,transaction_isolation =  
				CASE ses.transaction_isolation_level  
					WHEN 0 THEN 'Unspecified' 
					WHEN 1 THEN 'Read Uncommitted' 
					WHEN 2 THEN 'Read Committed' 
					WHEN 3 THEN 'Repeatable' 
					WHEN 4 THEN 'Serializable' 
					WHEN 5 THEN 'Snapshot' 
				END 
			,ConnectionWrites   = con.num_writes  
			,ConnectionReads    = con.num_reads  
			,ClientAddress      = con.client_net_address  
			,Authentication     = con.auth_scheme  
		---------------------------
		INTO #spWho 
		---------------------------
			FROM sys.dm_exec_requests er  
				LEFT JOIN sys.dm_exec_sessions ses  ON ses.session_id = er.session_id  
				LEFT JOIN sys.dm_exec_connections con  ON con.session_id = ses.session_id  
				OUTER APPLY sys.dm_exec_sql_text(er.sql_handle) as qt  

		WHERE ses.status   = 'running'
			ORDER BY 
			CPUTime desc,
			IOReads DESC

	--------------------------------------------------------------------------------------
	-- Query 01
	--SELECT *  FROM #spWho 
	--	ORDER BY ElapsedMS desc
	--------------------------------------------------------------------------------------
	DECLARE 
	     @ExecSql varchar(max)
   
	if (object_id('tempdb..#InpbufTmp') is not null)
		drop table #InpbufTmp


	CREATE TABLE #InpbufTmp(
	EventType NVARCHAR(MAX) NULL,
	Parameters INT NULL,
	EventInfo NVARCHAR(MAX) NULL
	)

	if (object_id('tempdb..#Inpbuffer') is not null)
		drop table #Inpbuffer

	CREATE TABLE #Inpbuffer(
	spid int,
	EventInfo NVARCHAR(MAX) NULL,
	CompanyName nvarchar(255)
	)


	SET @ExecSql = 'DECLARE @tBuff varchar(max); SET @tBuff = ''''; '
		SELECT TOP 10
		  @ExecSql +=  '  INSERT #InpbufTmp EXEC( '' DBCC INPUTBUFFER(' + RTRIM(spid) + ')''); SET @tBuff = (SELECT TOP 1 EventInfo FROM #InpbufTmp); INSERT INTO #Inpbuffer(spid,EventInfo,CompanyName) values (' + RTRIM(spid) + ', @tBuff, dbo.fn_getCompanyName(@tBuff)); DELETE FROM #InpbufTmp; '
		FROM #spWho 
		ORDER BY  CPUTime desc,	IOReads DESC
	PRINT RTRIM(@ExecSql)
	EXEC(@ExecSql) 

	--------------------------------------------------------------------------------------
	-- Query 02
	SELECT b.spid, w.DBName, w.Host, w.[Login], b.EventInfo, w.ObjectName, b.CompanyName, cast((w.ElapsedMS/1000)/60 as decimal(12,3)) ElapsedMIN, w.ElapsedMS, w.CPUTime, w.IOReads, w.IOWrites,
		w.LastWaitType, w.BlkBy, w.CommandType, w.StartTime,  w.ClientAddress, w.[Status]
		FROM #Inpbuffer b

	  INNER JOIN #spWho w on b.spid = w.SPID
	ORDER BY  w.CPUTime desc,
		w.IOReads DESC
	--------------------------------------------------------------------------------------	


-- END Process
--///////////////////////////////

END TRY
	BEGIN CATCH

		
		SELECT RTRIM(@Proc) , ERROR_NUMBER() 'ERROR_NUMBER'
		, ERROR_SEVERITY() as 'ERROR_SEVERITY'
		, ERROR_STATE() as 'ERROR_STATE'
		, ERROR_MESSAGE() as 'ERROR_MESSAGE';

	END CATCH

    SET @dateTimeEnd  = GETDATE();


IF @IsDisplay = 1
BEGIN
 PRINT ''
 PRINT 'End Processing ' + CONVERT(VarChar(20), GETDATE(), 109)
END

SET NOCOUNT OFF
RETURN
GO
PRINT N'Creating [dbo].[Tools_WaitingTask2]...';


GO
/*
 Author: Billie D. Lepasana
 Date Created:  Oct 7, 2011 @ 10am EST
 SQL Server Version:  2008
 Description:
    Look at snapshot of current task running that is waiting
    See if there are blocking issue

 Version History:
	1.0

*/
CREATE PROCEDURE [dbo].[Tools_WaitingTask2]
--///////////////////////////////
-- Parameters
	
--------------------------------------------
	 @IsDisplay				BIT             = 1
        /* 1 to display feedback msg, 0 not */

AS
SET NOCOUNT ON;
SET XACT_Abort ON;

IF @IsDisplay = 1
BEGIN
 PRINT ''
 PRINT REPLICATE('=',50)
 PRINT 'Start Processing ' + CONVERT(VarChar(20), GETDATE(), 109)
 PRINT REPLICATE('-',25)
 PRINT 'Server Name : ' + @@ServerName 
 PRINT 'DB: ' + DB_name()
 PRINT REPLICATE('-',25)
 PRINT ''
END

BEGIN TRY		
	DECLARE 
		-----------------------------
		-- Error Logging
        @Proc	NVARCHAR(75) = 'Tools_WaitingTask'
--///////////////////////////////
-- Variables
	   ,@dateTimeEnd DATETIME

--///////////////////////////////
-- Initialized



--///////////////////////////////
-- BEGIN Process

	SELECT 	dm_ws.session_ID,
	dm_ws.wait_duration_ms,
	dm_ws.wait_type,
	dm_es.status,
	dm_t.TEXT,
	dm_qp.query_plan,
	dm_ws.blocking_session_id,
	dm_ws.blocking_exec_context_id,
	dm_ws.resource_description,
	dm_es.cpu_time,
	dm_es.memory_usage,
	dm_es.logical_reads,
	dm_es.total_elapsed_time,
	dm_es.program_name,
	DB_NAME(dm_r.database_id) DatabaseName,
	-- Optional columns
	dm_ws.blocking_session_id,
	dm_r.wait_resource,
	dm_es.login_name,
	dm_r.command,
	dm_r.last_wait_type
	FROM sys.dm_os_waiting_tasks dm_ws
	INNER JOIN sys.dm_exec_requests dm_r ON dm_ws.session_id = dm_r.session_id
	INNER JOIN sys.dm_exec_sessions dm_es ON dm_es.session_id = dm_r.session_id
	CROSS APPLY sys.dm_exec_sql_text (dm_r.sql_handle) dm_t
	CROSS APPLY sys.dm_exec_query_plan (dm_r.plan_handle) dm_qp

	order by dm_ws.blocking_session_id DESC, dm_ws.wait_duration_ms desc

-- END Process
--///////////////////////////////

END TRY
	BEGIN CATCH

		
		SELECT RTRIM(@Proc) , ERROR_NUMBER() 'ERROR_NUMBER'
		, ERROR_SEVERITY() as 'ERROR_SEVERITY'
		, ERROR_STATE() as 'ERROR_STATE'
		, ERROR_MESSAGE() as 'ERROR_MESSAGE';

	END CATCH

    SET @dateTimeEnd  = GETDATE();


IF @IsDisplay = 1
BEGIN
 PRINT ''
 PRINT 'End Processing ' + CONVERT(VarChar(20), GETDATE(), 109)
END

SET NOCOUNT OFF
RETURN
GO
-- reindex ALL without filter
IF NOT EXISTS(SELECT TOP 1 1 FROM [dbo].[db_excluded_index] WHERE objectName='ALL')
BEGIN
	INSERT INTO [dbo].[db_excluded_index]
	(      [BatchID]
		  ,[objectName]
		  ,[indexName]
		  ,[IsIncluded]
		  ,[StatusID]
		  ,[Notes]
	)
	VALUES (1,'ALL',NULL,1,1,'Include ALL Indexes')
END
GO

GO
PRINT N'Update complete.';


GO
